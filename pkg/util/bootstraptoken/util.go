package bootstraptoken

import (
	"time"

	"github.com/pkg/errors"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	bootstraptokenapi "k8s.io/cluster-bootstrap/token/api"
	bootstraptokenutil "k8s.io/cluster-bootstrap/token/util"
)

func GenerateBootstrapToken(t time.Duration) (string, *corev1.Secret, error) {

	token, err := bootstraptokenutil.GenerateBootstrapToken()
	if err != nil {
		return "", nil, err
	}
	substrs := bootstraptokenutil.BootstrapTokenRegexp.FindStringSubmatch(token)
	// TODO: Add a constant for the 3 value here, and explain better why it's needed (other than because how the regexp parsin works)
	if len(substrs) != 3 {
		return "", nil, errors.Errorf("the bootstrap token %q was not of the form %q", token, bootstraptokenapi.BootstrapTokenPattern)
	}
	tokenID := substrs[1]
	tokenSecret := substrs[2]

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      bootstraptokenutil.BootstrapTokenSecretName(tokenID),
			Namespace: metav1.NamespaceSystem,
		},
		Type: bootstraptokenapi.SecretTypeBootstrapToken,
		StringData: map[string]string{
			bootstraptokenapi.BootstrapTokenDescriptionKey:      "Bootstrap token generated by Kubernikus",
			bootstraptokenapi.BootstrapTokenIDKey:               tokenID,
			bootstraptokenapi.BootstrapTokenSecretKey:           tokenSecret,
			bootstraptokenapi.BootstrapTokenExpirationKey:       metav1.Now().Add(t).Format(time.RFC3339),
			bootstraptokenapi.BootstrapTokenUsageAuthentication: "true",
			bootstraptokenapi.BootstrapTokenUsageSigningKey:     "true",
		},
	}

	return token, secret, nil
}
